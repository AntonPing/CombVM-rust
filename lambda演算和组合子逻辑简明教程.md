# lambda演算和组合子逻辑简明教程
我们用以下的方式递推定义lambda项（lambda term）
* 任何的变量都是lambda项，如x，y。
* 假如T是一个lambda项，那么\x.T也是一个lambda项，其中x是一个任意的变量。称为lambda抽象（Abstraction）
* 假如T1和T2都是lambda项，那么（T1 T2）也是一个lambda项。称为lambda应用。（Application）
* 其余的所有概念都不是lambda项

然后我们给出自由变量的定义如下：

* 变量x中的自由变量组成集合就是{x}（就是说他自己就是自由变量）。
* 所有\x.T中的自由变量组成的集合，就是T的自由变量集合中移除x得到的集合。
* 所有（T1 T2）中的自由变量组成的集合，就是T1的自由变量和T2的自由变量的并集。

由此我们可得知（\x.(x y))中x不是自由变量，但y是自由变量，

以上就是lambda演算和lambda项中自由变量的定义，可以看出lambda项的定义是递推定义并且完全形式化的，本身并没有任何语义上的关联。那么这种完全抽象的形式有什么具体的用处呢？直觉上我们可以把lambda演算类比成计算机编程中的函数定义，\x.t中的x即为变量名，而t即为函数体。而((\x.a) b)则为一个函数应用，即把b作为函数(\x.a)的参数去调用。而自由变量指的是在lambda项出现了但是没有被绑定到某一个参数上的变量。例如以下的C语言函数是不能通过编译的。

int add_x(int n) { return n + x; }

这个函数通不过编译的原因是x没有被定义，用lambda的术语来说就是出现了自由变量x。把该函数写成lambda项的形式就是(\n. n + x)。这里读者可能会有疑惑，因为我们并没有定义四则运算，纯粹的lambda演算确实是没有运算符（例如加减乘除）和常量（例如42）的，但是我们在把lambda演算作为形式工具的时候往往会预先定义一个算符和常量的集合。并且出于习惯的因素我们把+当成了中缀操作符，但是如果为了形式上的一致性的话最好使用前缀，即(\n.+ n x)。因为+不过是我们预先定义的一个函数而已，既然是一个函数，那么就应该放在参数的前面。

lambda演算的作用是表达一种代换规律。例如在数学联立方程中，如果我们写：
X = 42
Y = X * 2 + 3
那么我们可以做出代换，得到
Y = X * 2 + 3 = 42 * 2 + 3 = 87

这种代换在计算机语言理论中称之为“引用透明”，而lambda项就是用来表达这种代换规律的。这个代换用lambda表达出来就是（（\x.x * 2 + 3）42）= 42 * 2 + 3 = 87

为了更加深入的讲解这种代换规则，我们规定一个记法，用t[x/y]表示将t中的所有*自由*变量x替换成y的操作（x和y可以是任何两个变量），例如 \x.(x y)[x/z] = \x.(x z)。然后我们用这个记法定义lambda演算的约归方式（也就是代换规律），很简单，只有两条规则——alpha变换和beta约归。

* alpha变换公式 \x.t -> \y.t[x/y] 其中y是任选的变量

  用自然语言解释这个变换就是将一个函数的参数以及函数体中的同名的变量（必须是自由变量）同时改名，并不影响函数的意义。（这点在C语言等计算机编程语言中也是如此）

* beta约归公式 ((\x.a) b) -> a[x/b]

   这个变换就是lambda演算定义的唯一一种约归规则，即是：如果把一个函数(\x.a)和一个参数b相结合，则可以约归此项，用函数调用的参数去替换函数体中的对应的变量。（这点在C语言有时是成立的，但并不总是如此）

在这里我们举一个C语言的例子，假如我们有这么一段程序。

static int n = 42;

int double_num(int num) {

​	return num + num;

}

请注意此时如果根据透明引用的假设，下面两个表达式应当是等价的

1、double_num(n++) ;

2、（n++） + （n++）;

但是如果运行两个语句的话，语句一的结果为84而语句二为85，由此可证明C语言不是引用透明的，而这种不透明性（在这个例子中）来源于对全局变量的操作。



现在我们开始进入主题，组合子演算。
实际上组合子演算的历史更为悠久，在lambda演算被Church提出之前就已经出现，组合子演算（以下简称CL）的发明者是乌克兰裔的俄国数学家和逻辑学家Moses Ilyich Schönfinkel（俄语名Моисей Исаевич Шейнфинкель）。Schönfinkel 1889年出生于乌克兰，后在敖德萨大学学习数学。从1914年到1924年，Schönfinkel来到德国，加入到希尔伯特领导的哥廷根学派，从事研究。正是在这个期间Schönfinkel专注于数理逻辑的研究，重点是如何简化逻辑学的原始概念，力图用最小数量的原始概念派生所有逻辑运算。Schönfinkel在1920年12月7日在哥廷根大学举行的数学学术会议上首次做了关于CL的基本框架和技术细节的口头发表，而作为书面论文，因种种原因直到1924年才以《关于数理逻辑的基本构件》为标题发表（über die Bausteine der mathematischen Logik）。

令人遗憾的是，Schönfinkel此后再未发表过关于组合逻辑方面的论文，最后一篇论文发表于1928年，是和别人联合署名并作为第二作者，内容是关于可判定性问题的，即本篇开始提到的莱布尼茨第二问题。而且令人不解的是，这两篇论文都是在同事“帮助”下发表的，当然这些同事也是著名的数理逻辑学家，Behmann和Bernays，后者后来又和Curry合作研究CL。据说Schönfinkel在1927年左右患上了心理病患，一直在疗养院生活，因此发表论文可能有些技术上的困难，因此这仅有的两篇论文是在同事的帮助下才完成发表。Schönfinkel后来的生活主要是在莫斯科度过，生活拮据、陷入贫困，经济上一直接受朋友的帮助。在长期患病之后于1942年与世长辞。令人匪夷所思的是，他逝世后其手稿竟然被邻居在战争中当做“燃料”给烧了。


下面我们开始定义一个最为常见的完备组合子集。SKI 组合子集，依旧是使用递推定义：

* S是一个ski项，其等于（\f.\g.\x.（f x）（g x））
* K是一个ski项，其等于（\x.\y.x）
* I是一个ski项，其等于（\x.x）
* 假设T1和T2是两个ski项，则（T1 T2）也是一个ski项。称为ski应用
* 其余所有概念都是不是ski项

我们可以看出组合子逻辑中消去了对变量的依赖，丢失了单个的变量（x）和函数抽象（\x.t），但保留了lambda演算中的应用（Application）。到这里可能有人已经发现了一个漏洞——我们的ski组合子是通过lambda定义的，但实际上组合子的发明比lambda还要早，因此最初的定义一定是不依赖lambda演算的。

实际上ski组合子的等价定义不止一种，此处出于上下文的关系采用了使用lambda演算的定义（顺带一提，类似（\f.\g.\x.（f x）（g x））这样没有自由变量的lambda项又称之为超组合子super combinator），一种更为常用的定义是直接把约归规则和定义强绑定起来的，内容如下。

* S,K,I都是ski项

* 假如T1 T2都是ski项，则（T1 T2）也是ski项，称为一个ski应用（Application）

* ski项上定义了一个约归规则，对于任意的

  1、(((S a) b) c) 可以归为 ((a c) (b c))

  2、((K a) b) 可约归为 a

  3、(I a) 可约归为a

实际上可以看出该定义更为简洁而且与使用lambda演算的定义是等价的，因为如果我们使用lambda演算的约归规则也可以得到一样的结果，即：

(((S a) b) c) := 定义为 

:= ((((\f.\g.\x. (f x) (g x)) a) b) c)  => 将a代入函数

=>  (((\g.\x. (a x) (g x)) b) c)  => 将b代入函数

=> ((\x. (a x) (b x)) c)  =>  将c代入函数

=> ((a c) (b c))

等价于我们定义的规则，其余的K组合子和I组合子的等价证明也是一样的，即使用lambda的定义版本和不使用lambda定义的版本在约归时的行为是完全一样的。（此处不对“行为一样”做出更为严谨的定义，因其显然而琐碎）

我们现在对等价的项做出定义：（内涵等价和外延等价）
内涵等价的lambda项：假如T1就是T2，或者通过alpha变换后可以变为同一个表达式，则他们内涵等价。

外延等价：对于任何的lambda项X，如果（T1 X）和（T2 X）都能约归到某个相同的项，则称他们外延等价。

内涵等价的lambda项显然是外延等价的。

乍一看组合子逻辑比lambda演算表达范围要弱的多，但是一个违反数学直觉的是——lambda演算和ski组合子逻辑的表达范围是一样的，即任意一个lambda表达式都存在一个对应的与其外延等价的ski组合子项（并不唯一）。

证明：
1、任意一个ski组合子项都能由lambda项表达。
显然成立，甚至可以说定义如此（如果我们采用lambda定义的话）。假如一个项是SKI组合应用构成的项，则可以将其中的SKI分别替换成对应的lambda项，于是我们有了一个合法的lambda项，证毕。
2、任意一个lambda项都能由ski组合子项表达。

我们通过构造法证明，即先构造一个变换算法T[X]（T是一个变换函数，接受一个lambda项，返回一个lambda项），并且证明该算法的正确性和可停机性（就是说他不会陷入死循环），即可证得原命题。
1、T[V] = > V

2、T[(E1 E2)] = >(T[E1] T[E2])

3、T[λx.E] = > (K T[E])（如果x在E中没有自由出现）

4、T[λx.x] = > I

5、T[λx.λy.E] = > T[λx.T[λy.E]]（如果x在E中自由出现）

6、T[λx.(E1 E2)] =>（S T[λx.E1] T[λx.E2]）

首先我们注意到这六条模式匹配是完全的（即没有遗漏项），任意一个lambda都match到六条规则中的某一条。

其次我们证明算法的正确性，即每条模式匹配左右手都是等价的
引理: 先注意到一个事实，假设T1和T1‘等价，T2和T2’等价，则（T1 T2）和（T1‘ T2’）等价

1、左右手相同，显然等价
2、对lambda应用进行变换，则等于对应用的左右两项分别变换，只需证明其余规则等价则此规则亦等价（我们的引理）。
3、如果\x.E中的x在E中自由出现，则等价于（K E），此处的证明是明显的，因为对于任何lambda项y，（K E）y 约归到E，而（\x.E）y在x自由出现的情况下也约归到E。

4、\x.x = I，此为定义，显然。

5、只需证明其余规则等价则此规则亦等价（我们的引理）。

6、这一步是证明的核心，即我们要证明对于任意的lambda项

形如（\x.（T1 T2）），其都外延等价于 （S （\x. T1）（\x. T2））

既然是要证明外延等价，不妨将一个任意的y代入，我们需要证明：
（（\x.（T1 T2））y）等价于 （（S （\x. T1）（\x. T2））y）

左式等于（（\x.（T1 T2））y） =  (T1 T2)[x/y]  = (T1[x/y]  T2[x/y])

右式等于（（S （\x. T1）（\x. T2））y） = （（\x. T1）y ）（（\x. T2）y） = (T1[x/y]  T2[x/y]) 

左右边相等，命题得证。



接下来是关于算法停机性的证明：

先证明一个较弱的命题：假设一个lambda项是不包含应用（Application）的项，即只包含基本变量和抽象（Abstraction），那么算法必定停机。可以想象，既然没有应用，我们的lambda项必定是一个形如\a.\b. ... \z. x 的项，其中x可能被绑定到a...z中的某一个，也可能是该项自由变量（没有被绑定）。

这个项包含的抽象个数必定是有限的（我们不研究无穷长lambda项），观察规则3、4、5（无需观察6，因为我们的项中没有应用），

规则3中，T[λx.E] = > (K T[E])  抽象的数量减少了1,

规则4中，T[λx.x] = > I 抽象的数量也减少了1,

规则5中，T[λx.λy.E] = > T[λx.T[λy.E]] 抽象数量到底有没有减少需要讨论，但是可以肯定的是规则5不可能无穷地应用下去，必定会在某一时刻终止（最终会变成类似T[\a.T[\b. ... T[\z. x] ...]]的形状，然后递归就开始从内往外返回了），而在终止的那一时刻应用的必定是规则3或规则4，因此规则5递归终止时也会导致抽象数量减少。

很好，也就是说对于没有应用的lambda项该算法递归会终止，并且得到一个没有抽象的项上，这个项要么是K,要么是I,要么是个自由变量。（不会有S因为我们没法应用规则6，我们的项中没有应用）

到这一步其实已经几乎是结尾了，我们现在来证明原命题：对任何一个lambda项该算法都能停机。我们先观察规则2 ，T[(E1 E2)] = >(T[E1] T[E2])中 E1和E2每个都包含严格的比 (E1 E2)更少的应用，所以递归必定终止于根本没有应用的lambda项之上。而规则6中，T[λx.(E1 E2)] =>（S T[λx.E1] T[λx.E2]）也同理，因为 \x.E1 和 \x.E2 包含的应用也比（E1 E2）更少。任何一个带有应用的lambda项最终将会在递归中变为没有应用的lambda项，而对于没有应用的lambda项递归将会终止。命题得证。

说了这么多现在来总结一下三个组合子的直觉作用，记得我们在规则6正确性的证明上使用了这两个等式。

左式等于（（\x.（T1 T2））y） =  (T1 T2)[x/y]  = (T1[x/y]  T2[x/y])

右式等于（（S （\x. T1）（\x. T2））y） = （（\x. T1）y ）（（\x. T2）y） = (T1[x/y]  T2[x/y]) 

其实这个也就是S组合子的直觉作用——将一个变量（或者说环境）同时传递到T1和T2中，左边的式子直觉上对应了“将（T1 T2）中的x替换为y”这样的语义，而右边的式子展开后直觉上对应了“将T1中的x替换成y，将T2中的x替换成y，然后将替换后的T1和T2应用起来（T1 T2）”，显然先结合后替换和先替换后结合是没有本质上的区别的。S组合子的作用就是把变量传进应用的两边。

而K组合子直觉上对应了“接受一个参数，然后把该参数丢弃，返回一个常量”，即函数的值与接受的变量完全无关。

I组合子直觉上对应了自反函数id，即返回变量本身。（其实S，K，I有时也写作S，K，Id）





